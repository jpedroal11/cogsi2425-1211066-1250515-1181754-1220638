plugins {
    id 'org.springframework.boot' version '3.3.0'
    id 'io.spring.dependency-management' version '1.1.5'
    id 'java'
    id 'application'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-hateoas'
    runtimeOnly 'com.h2database:h2'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

test {
    useJUnitPlatform()
}

// Disable bootJar to avoid compatibility issues
tasks.named('bootJar') {
    enabled = false
}

// Enable regular jar task
tasks.named('jar') {
    enabled = true
    archiveClassifier = '' // Remove the 'plain' classifier
}

tasks.named('bootDistZip') {
    dependsOn 'jar'
}

tasks.named('bootDistTar') {
    dependsOn 'jar'
}

tasks.named('bootStartScripts') {
    dependsOn 'jar'
}

// --- deployToDev task ---
def deployDir = "$buildDir/deployment/dev"
def libDir = "$deployDir/lib"
def jarFile = layout.buildDirectory.file("libs/${project.name}-${project.version}.jar")

// 1Clean deployment directory
tasks.register("cleanDevDeployment", Delete) {
    group = "deployment"
    description = "Deletes previous development deployment directory"
    delete deployDir
}

// Copy main application JAR
tasks.register("copyAppJar", Copy) {
    group = "deployment"
    description = "Copies application JAR into the deployment directory"
    dependsOn "jar"

    from jarFile
    into deployDir
    rename { "application.jar" }
}

// Copy runtime dependencies
tasks.register("copyRuntimeDeps", Copy) {
    group = "deployment"
    description = "Copies runtime dependencies to the deployment lib directory"
    dependsOn "jar"

    from configurations.runtimeClasspath
    into libDir
    exclude { it.file.name.contains(project.name) } // avoid copying the main jar
}

//Copy configuration files (with property substitution)
tasks.register("copyConfigFiles", Copy) {
    group = "deployment"
    description = "Copies configuration files with build metadata filtering"

    from("src/main/resources") {
        include "*.properties"
        expand([
                projectVersion: project.version,
                buildTimestamp: new Date().format("yyyy-MM-dd HH:mm:ss"),
                deploymentEnv: "dev"
        ])
        filteringCharset = "UTF-8"
    }
    into deployDir
}

// Aggregate task – orchestrates everything above
tasks.register("deployToDev") {
    group = "deployment"
    description = "Deploys the app to the development directory"

    dependsOn(
            "cleanDevDeployment",
            "copyAppJar",
            "copyRuntimeDeps",
            "copyConfigFiles"
    )

    doLast {
        println "✅ Deployment completed successfully to: $deployDir"
        println "\nDeployment summary:"
        fileTree(deployDir).forEach { file ->
            println " - " + file.path - deployDir
        }
    }
}


// --- runFromDist task ---
application {
    mainClass = 'payroll.PayrollApplication'
}

tasks.register("runFromDist") {
    dependsOn 'installDist'
    group = "application"
    description = "Runs the app using generated distribution scripts"

    doLast {
        def isWindows = System.getProperty("os.name").toLowerCase().contains("windows")
        def scriptDir = file("build/install/${project.name}/bin")
        def scriptFile = isWindows ? 
            file("$scriptDir/${project.name}.bat") : 
            file("$scriptDir/${project.name}")
        
        if (!scriptFile.exists()) {
            throw new RuntimeException("Distribution script not found at: $scriptFile")
        }
        
        println "Starting application from distribution..."
        println "Script: $scriptFile"
        println "=" * 50
        
        def command = isWindows ? 
            ["cmd", "/c", scriptFile.absolutePath] : 
            [scriptFile.absolutePath]
        
        def processBuilder = new ProcessBuilder(command)
        processBuilder.directory(scriptDir)
        processBuilder.inheritIO()
        
        try {
            // Start the process without waiting for it to complete
            def process = processBuilder.start()
            
            println "Application started with PID: ${process.pid()}"
            println "Access the application at: http://localhost:8080/employees"
            println "Press Ctrl+C to stop the application"
            
            // Keep the process running until Gradle is terminated
            Thread keepAlive = new Thread({
                while (process.isAlive()) {
                    Thread.sleep(1000)
                }
            })
            keepAlive.start()
            keepAlive.join()
            
        } catch (Exception e) {
            println "Failed to start application: ${e.message}"
            throw e
        }
    }
}

// --- packageJavadoc task ---
tasks.register("packageJavadoc", Zip) {
    group = "documentation"
    description = "Zips generated Javadoc"
    dependsOn 'javadoc'

    from javadoc.destinationDir
    archiveFileName = "${project.name}-${project.version}-javadoc.zip"
    destinationDirectory = layout.buildDirectory.dir("docs")
    
    doLast {
        println "Javadoc packaged: ${archiveFile.get()}"
    }
}

// --- Integration Test Source Set ---
sourceSets {
    integrationTest {
        java {
            srcDir 'src/integrationTest/java'
        }
        resources {
            srcDir 'src/integrationTest/resources'
        }
        compileClasspath += sourceSets.main.output + sourceSets.test.output
        runtimeClasspath += sourceSets.main.output + sourceSets.test.output
    }
}

configurations {
    integrationTestImplementation.extendsFrom testImplementation
    integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
    integrationTestCompileClasspath.extendsFrom testCompileClasspath
    integrationTestRuntimeClasspath.extendsFrom testRuntimeClasspath
}

// Add explicit JUnit Platform dependency for integration tests
dependencies {
    integrationTestImplementation 'org.junit.platform:junit-platform-launcher'
    integrationTestImplementation 'org.junit.jupiter:junit-jupiter-engine'
    integrationTestImplementation 'org.junit.jupiter:junit-jupiter-api'
}

tasks.register("integrationTest", Test) {
    description = "Runs integration tests."
    group = "verification"
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter test
    useJUnitPlatform()
    
    // Add test logging to see what's happening
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
    }
}

// Make integrationTest part of the check lifecycle
check.dependsOn integrationTest