plugins {
    id 'org.springframework.boot' version '3.3.0'
    id 'io.spring.dependency-management' version '1.1.5'
    id 'java'
    id 'application'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-hateoas'
    runtimeOnly 'com.h2database:h2'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

test {
    useJUnitPlatform()
}

// Disable bootJar to avoid compatibility issues
tasks.named('bootJar') {
    enabled = false
}

// Enable regular jar task
tasks.named('jar') {
    enabled = true
    archiveClassifier = '' // Remove the 'plain' classifier
}

tasks.named('bootDistZip') {
    dependsOn 'jar'
}

tasks.named('bootDistTar') {
    dependsOn 'jar'
}

tasks.named('bootStartScripts') {
    dependsOn 'jar'
}

// --- deployToDev task ---
tasks.register("deployToDev") {
    group = "deployment"
    description = "Deploys app to development directory"
    
    def deployDir = "$buildDir/deployment/dev"
    
    // Depend on jar instead of assemble to avoid bootJar
    dependsOn 'jar'
    
    doLast {
        logger.lifecycle("Starting deployment to: $deployDir")
        
        // 1. Clean deployment directory
        delete deployDir
        
        // 2. Copy main application artifact
        def jarFile = layout.buildDirectory.file("libs/${project.name}-${project.version}.jar").get().asFile
        if (jarFile.exists()) {
            copy {
                from jarFile
                into deployDir
                rename { "application.jar" }
            }
            println "Copied application JAR"
        } else {
            println "Application JAR not found: ${jarFile.path}"
            // List what's actually in the libs directory for debugging
            def libsDir = layout.buildDirectory.dir("libs").get().asFile
            if (libsDir.exists()) {
                println "Contents of libs directory:"
                libsDir.eachFile { file ->
                    println "   - ${file.name}"
                }
            }
        }
        
        // 3. Copy runtime dependencies
        def libDir = "$deployDir/lib"
        mkdir libDir
        copy {
            from configurations.runtimeClasspath
            into libDir
            // Exclude the main application jar from dependencies
            exclude { it.file.name.contains(project.name) }
        }
        println "Copied runtime dependencies"
        
        // 4. Copy and filter configuration files
        def configFiles = fileTree('src/main/resources').include('*.properties')
        if (!configFiles.empty) {
            copy {
                from 'src/main/resources'
                into deployDir
                include '*.properties'
                expand([
                    projectVersion: project.version,
                    buildTimestamp: new Date().format("yyyy-MM-dd HH:mm:ss"),
                    deploymentEnv: 'dev'
                ])
                filteringCharset = 'UTF-8'
            }
            println "Copied and filtered configuration files"
        } else {
            println "No properties files found to copy"
        }
        
        logger.lifecycle("Deployment completed successfully to: $deployDir")
        
        // Show what was deployed
        println "\n Deployment Summary:"
        fileTree(deployDir).each { file ->
            def relativePath = file.path - deployDir
            println "    $relativePath"
        }
    }
}

// --- runFromDist task ---
application {
    mainClass = 'payroll.PayrollApplication'
}

tasks.register("runFromDist") {
    dependsOn 'installDist'
    group = "application"
    description = "Runs the app using generated distribution scripts"

    doLast {
        def isWindows = System.getProperty("os.name").toLowerCase().contains("windows")
        def scriptDir = file("build/install/${project.name}/bin")
        def scriptFile = isWindows ? 
            file("$scriptDir/${project.name}.bat") : 
            file("$scriptDir/${project.name}")
        
        if (!scriptFile.exists()) {
            throw new RuntimeException("Distribution script not found at: $scriptFile")
        }
        
        println "Starting application from distribution..."
        println "Script: $scriptFile"
        println "=" * 50
        
        def command = isWindows ? 
            ["cmd", "/c", scriptFile.absolutePath] : 
            [scriptFile.absolutePath]
        
        def processBuilder = new ProcessBuilder(command)
        processBuilder.directory(scriptDir)
        processBuilder.inheritIO()
        
        try {
            // Start the process without waiting for it to complete
            def process = processBuilder.start()
            
            println "Application started with PID: ${process.pid()}"
            println "Access the application at: http://localhost:8080/employees"
            println "Press Ctrl+C to stop the application"
            
            // Keep the process running until Gradle is terminated
            Thread keepAlive = new Thread({
                while (process.isAlive()) {
                    Thread.sleep(1000)
                }
            })
            keepAlive.start()
            keepAlive.join()
            
        } catch (Exception e) {
            println "Failed to start application: ${e.message}"
            throw e
        }
    }
}